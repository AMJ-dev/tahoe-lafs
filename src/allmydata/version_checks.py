"""
Produce reports about the versions of Python software in use by Tahoe-LAFS
for debugging and auditing purposes.

Ported to Python 3.
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

from future.utils import PY2
if PY2:
    from builtins import filter, map, zip, ascii, chr, hex, input, next, oct, open, pow, round, super, bytes, dict, list, object, range, str, max, min  # noqa: F401

__all__ = [
    "PackagingError",
    "get_package_versions",
    "get_package_versions_string",
    "normalized_version",
]

import attr

import os, platform, re, sys, traceback, pkg_resources

import six

import distro

from . import (
    __appname__,
    full_version,
    branch,
)
from .util import (
    verlib,
)

if getattr(sys, 'frozen', None):
    # "Frozen" python interpreters (i.e., standalone executables
    # generated by PyInstaller and other, similar utilities) run
    # independently of a traditional setuptools-based packaging
    # environment, and so pkg_resources.get_distribution() cannot be
    # used in such cases to gather a list of requirements at runtime
    # (and because a frozen application is one that has already been
    # "installed", an empty list suffices here).
    _INSTALL_REQUIRES = []
else:
    _INSTALL_REQUIRES = list(
        str(req)
        for req
        in pkg_resources.get_distribution(__appname__).requires()
    )

class PackagingError(EnvironmentError):
    """
    Raised when there is an error in packaging of Tahoe-LAFS or its
    dependencies which makes it impossible to proceed safely.
    """

def get_package_versions():
    """
    :return {str: str|NoneType}: A mapping from dependency name to dependency version
        for all discernable Tahoe-LAFS' dependencies.
    """
    return {
        dep.name: dep.version
        for dep
        in _vers_and_locs_list
    }

def get_package_versions_string(show_paths=False, debug=False):
    """
    :return str: A string describing the version of all Tahoe-LAFS
        dependencies.
    """
    version_format = "{}: {}".format
    comment_format = " [{}]".format
    path_format = " ({})".format

    res = []
    for dep in _vers_and_locs_list:
        info = version_format(dep.name, dep.version)
        if dep.comment:
            info = info + comment_format(dep.comment)
        if show_paths:
            info = info + path_format(dep.location)
        res.append(info)

    output = "\n".join(res) + "\n"

    if _cross_check_errors:
        output += _get_error_string(_cross_check_errors, debug=debug)

    return output

_distributor_id_cmdline_re = re.compile("(?:Distributor ID:)\s*(.*)", re.I)
_release_cmdline_re = re.compile("(?:Release:)\s*(.*)", re.I)

_distributor_id_file_re = re.compile("(?:DISTRIB_ID\s*=)\s*(.*)", re.I)
_release_file_re = re.compile("(?:DISTRIB_RELEASE\s*=)\s*(.*)", re.I)

_distname = None
_version = None

def normalized_version(verstr, what=None):
    try:
        suggested = verlib.suggest_normalized_version(verstr) or verstr
        return verlib.NormalizedVersion(suggested)
    except verlib.IrrationalVersionError:
        raise
    except Exception:
        cls, value, trace = sys.exc_info()
        new_exc = PackagingError("could not parse %s due to %s: %s"
                                 % (what or repr(verstr), cls.__name__, value))
        six.reraise(cls, new_exc, trace)

def _get_error_string(errors, debug=False):

    msg = "\n%s\n" % ("\n".join(errors),)
    if debug:
        msg += (
            "\n"
            "For debugging purposes, the PYTHONPATH was\n"
            "  %r\n"
            "install_requires was\n"
            "  %r\n"
            "sys.path after importing pkg_resources was\n"
            "  %s\n"
            % (
                os.environ.get('PYTHONPATH'),
                _INSTALL_REQUIRES,
                (os.pathsep+"\n  ").join(sys.path),
            )
        )
    return msg

def _cross_check(pkg_resources_vers_and_locs, imported_vers_and_locs_list):
    """
    This function returns a list of errors due to any failed cross-checks.

    :rtype: [str]
    """

    from ._auto_deps import not_import_versionable

    errors = []
    not_pkg_resourceable = ['python', 'platform', __appname__.lower(), 'openssl']

    for dep in imported_vers_and_locs_list:
        name = dep.name.lower()
        imp_ver = dep.version
        imp_loc = dep.location
        imp_comment = dep.comment
        if name not in not_pkg_resourceable:
            if name not in pkg_resources_vers_and_locs:
                if name == "setuptools" and "distribute" in pkg_resources_vers_and_locs:
                    pr_ver, pr_loc = pkg_resources_vers_and_locs["distribute"]
                    if not (os.path.normpath(os.path.realpath(pr_loc)) == os.path.normpath(os.path.realpath(imp_loc))
                            and imp_comment == "distribute"):
                        errors.append("Warning: dependency 'setuptools' found to be version %r of 'distribute' from %r "
                                      "by pkg_resources, but 'import setuptools' gave version %r [%s] from %r. "
                                      "A version mismatch is expected, but a location mismatch is not."
                                      % (pr_ver, pr_loc, imp_ver, imp_comment or 'probably *not* distribute', imp_loc))
                else:
                    errors.append("Warning: dependency %r (version %r imported from %r) was not found by pkg_resources."
                                  % (name, imp_ver, imp_loc))
                continue

            pr_ver, pr_loc = pkg_resources_vers_and_locs[name]
            if imp_ver is None and imp_loc is None:
                errors.append("Warning: dependency %r could not be imported. pkg_resources thought it should be possible "
                              "to import version %r from %r.\nThe exception trace was %r."
                              % (name, pr_ver, pr_loc, imp_comment))
                continue

            # If the pkg_resources version is identical to the imported version, don't attempt
            # to normalize them, since it is unnecessary and may fail (ticket #2499).
            if imp_ver != 'unknown' and pr_ver == imp_ver:
                continue

            try:
                pr_normver = normalized_version(pr_ver)
            except verlib.IrrationalVersionError:
                continue
            except Exception as e:
                errors.append("Warning: version number %r found for dependency %r by pkg_resources could not be parsed. "
                              "The version found by import was %r from %r. "
                              "pkg_resources thought it should be found at %r. "
                              "The exception was %s: %s"
                              % (pr_ver, name, imp_ver, imp_loc, pr_loc, e.__class__.__name__, e))
            else:
                if imp_ver == 'unknown':
                    if name not in not_import_versionable:
                        errors.append("Warning: unexpectedly could not find a version number for dependency %r imported from %r. "
                                      "pkg_resources thought it should be version %r at %r."
                                      % (name, imp_loc, pr_ver, pr_loc))
                else:
                    try:
                        imp_normver = normalized_version(imp_ver)
                    except verlib.IrrationalVersionError:
                        continue
                    except Exception as e:
                        errors.append("Warning: version number %r found for dependency %r (imported from %r) could not be parsed. "
                                      "pkg_resources thought it should be version %r at %r. "
                                      "The exception was %s: %s"
                                      % (imp_ver, name, imp_loc, pr_ver, pr_loc, e.__class__.__name__, e))
                    else:
                        if pr_ver == 'unknown' or (pr_normver != imp_normver):
                            if not os.path.normpath(os.path.realpath(pr_loc)) == os.path.normpath(os.path.realpath(imp_loc)):
                                errors.append("Warning: dependency %r found to have version number %r (normalized to %r, from %r) "
                                              "by pkg_resources, but version %r (normalized to %r, from %r) by import."
                                              % (name, pr_ver, str(pr_normver), pr_loc, imp_ver, str(imp_normver), imp_loc))

    return errors

def _get_openssl_version():
    try:
        from OpenSSL import SSL
        return _extract_openssl_version(SSL)
    except Exception:
        return ("unknown", None, None)

def _extract_openssl_version(ssl_module):
    openssl_version = ssl_module.SSLeay_version(ssl_module.SSLEAY_VERSION)
    if openssl_version.startswith('OpenSSL '):
        openssl_version = openssl_version[8 :]

    (version, _, comment) = openssl_version.partition(' ')

    try:
        openssl_cflags = ssl_module.SSLeay_version(ssl_module.SSLEAY_CFLAGS)
        if '-DOPENSSL_NO_HEARTBEATS' in openssl_cflags.split(' '):
            comment += ", no heartbeats"
    except Exception:
        pass

    return (version, None, comment if comment else None)


def _get_platform():
    # Our version of platform.platform(), telling us both less and more than the
    # Python Standard Library's version does.
    # We omit details such as the Linux kernel version number, but we add a
    # more detailed and correct rendition of the Linux distribution and
    # distribution-version.
    if "linux" in platform.system().lower():
        return (
            platform.system() + "-" +
            "_".join(distro.linux_distribution()[:2]) + "-" +
            platform.machine() + "-" +
            "_".join([x for x in platform.architecture() if x])
        )
    else:
        return platform.platform()


def _ensure_text_optional(o):
    """
    Convert a value to the maybe-Future-ized native string type or pass through
    ``None`` unchanged.

    :type o: NoneType|bytes|str

    :rtype: NoneType|str
    """
    if o is None:
        return None
    return six.ensure_text(o)


@attr.s
class _Dependency(object):
    """
    A direct or indirect Tahoe-LAFS dependency.

    :ivar name: The name of this dependency.
    :ivar version: If known, a string giving the version of this dependency.
    :ivar location: If known, a string giving the path to this dependency.
    :ivar comment: If relevant, some additional free-form information.
    """
    name = attr.ib(
        converter=six.ensure_text,
        validator=attr.validators.instance_of(str),
    )
    version = attr.ib(
        converter=_ensure_text_optional,
        validator=attr.validators.optional(attr.validators.instance_of(str)),
    )
    location = attr.ib(
        converter=_ensure_text_optional,
        validator=attr.validators.optional(attr.validators.instance_of(str)),
    )
    comment = attr.ib()


def _get_package_versions_and_locations():
    """
    Look up information about the software available to this process.

    :return: A two tuple.  The first element is a list of ``_Dependency``
        instances.  The second element is like the value returned by
        ``_cross_check``.
    """
    import warnings
    from ._auto_deps import package_imports, global_deprecation_messages, deprecation_messages, \
        runtime_warning_messages, warning_imports, ignorable

    # pkg_resources.require returns the distribution that pkg_resources attempted to put
    # on sys.path, which can differ from the one that we actually import due to #1258,
    # or any other bug that causes sys.path to be set up incorrectly. Therefore we
    # must import the packages in order to check their versions and paths.

    # This is to suppress all UserWarnings and various DeprecationWarnings and RuntimeWarnings
    # (listed in _auto_deps.py).

    warnings.filterwarnings("ignore", category=UserWarning, append=True)

    for msg in global_deprecation_messages + deprecation_messages:
        warnings.filterwarnings("ignore", category=DeprecationWarning, message=msg, append=True)
    for msg in runtime_warning_messages:
        warnings.filterwarnings("ignore", category=RuntimeWarning, message=msg, append=True)
    try:
        for modulename in warning_imports:
            try:
                __import__(modulename)
            except (ImportError, SyntaxError):
                pass
    finally:
        # Leave suppressions for UserWarnings and global_deprecation_messages active.
        for _ in runtime_warning_messages + deprecation_messages:
            warnings.filters.pop()

    pkg_resources_vers_and_locs = _compute_pkg_resources_vers_and_locs(_INSTALL_REQUIRES)

    packages = list(_compute_imported_packages(
        [(__appname__, 'allmydata')] + package_imports,
        pkg_resources_vers_and_locs,
    ))

    cross_check_errors = []

    if len(pkg_resources_vers_and_locs) > 0:
        imported_packages = set(dep.name.lower() for dep in packages)
        extra_packages = []

        for pr_name, (pr_ver, pr_loc) in pkg_resources_vers_and_locs.items():
            if pr_name not in imported_packages and pr_name not in ignorable:
                extra_packages.append(
                    _Dependency(
                        pr_name,
                        pr_ver,
                        pr_loc,
                        "according to pkg_resources",
                    ),
                )

        cross_check_errors = _cross_check(pkg_resources_vers_and_locs, packages)
        packages += extra_packages

    return packages, cross_check_errors


def _compute_pkg_resources_vers_and_locs(requires):
    """
    Get the ``pkg_resources`` idea of the dependencies for all of the given
    requirements.

    If the execution context is a frozen interpreter, just return an empty
    dictionary.

    :param [str] requires: Information about the dependencies of these
        requirements strings will be looked up and returned.

    :return {str: (str, str)}: A mapping from dependency name to a two-tuple
        of dependency version and location.
    """
    if not hasattr(sys, 'frozen'):
        return {
            p.project_name.lower(): (str(p.version), p.location)
            for p
            in pkg_resources.require(requires)
        }
    return {}


def _compute_imported_packages(packages, pkg_resources_vers_and_locs):
    """
    Get the import system's idea of all of the given packages.

    :param packages:
    """
    def package_dir(srcfile):
        return os.path.dirname(os.path.dirname(os.path.normcase(os.path.realpath(srcfile))))

    def get_version(module):
        if hasattr(module, '__version__'):
            return str(getattr(module, '__version__'))
        elif hasattr(module, 'version'):
            ver = getattr(module, 'version')
            if isinstance(ver, tuple):
                return '.'.join(map(str, ver))
            else:
                return str(ver)
        else:
            return 'unknown'

    for pkgname, modulename in packages:
        if modulename:
            try:
                __import__(modulename)
                module = sys.modules[modulename]
            except (ImportError, SyntaxError):
                etype, emsg, etrace = sys.exc_info()
                trace_info = (etype, str(emsg), ([None] + traceback.extract_tb(etrace))[-1])
                yield _Dependency(
                    pkgname,
                    None,
                    None,
                    trace_info,
                )
            else:
                comment = None
                if pkgname == __appname__:
                    comment = "%s: %s" % (branch, full_version)
                elif pkgname == 'setuptools' and hasattr(module, '_distribute'):
                    # distribute does not report its version in any module variables
                    comment = 'distribute'
                ver = get_version(module)
                loc = package_dir(module.__file__)
                if ver == "unknown" and pkgname in pkg_resources_vers_and_locs:
                    (pr_ver, pr_loc) = pkg_resources_vers_and_locs[pkgname]
                    if loc == os.path.normcase(os.path.realpath(pr_loc)):
                        ver = pr_ver
                yield _Dependency(
                    pkgname,
                    ver,
                    loc,
                    comment,
                )
        elif pkgname == 'python':
            yield _Dependency(
                pkgname,
                platform.python_version(),
                sys.executable,
                None,
            )
        elif pkgname == 'platform':
            yield _Dependency(
                pkgname,
                _get_platform(),
                None,
                None,
            )
        elif pkgname == 'OpenSSL':
            yield _Dependency(
                pkgname,
                *_get_openssl_version()
            )


_vers_and_locs_list, _cross_check_errors = _get_package_versions_and_locations()
